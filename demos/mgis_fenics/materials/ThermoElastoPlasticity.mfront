@DSL DefaultGenericBehaviour;
@Behaviour ThermoElastoPlasticity;
@Author Thomas Helfer;
@Date 19/04/2020;
@Description {
}

@Gradient StrainStensor εᵗᵒ;
εᵗᵒ.setGlossaryName("Strain");

@Flux StressStensor σ;
σ.setGlossaryName("Stress");

@Gradient TemperatureGradient ∇T;
∇T.setGlossaryName("TemperatureGradient");

@Flux HeatFlux j;
j.setGlossaryName("HeatFlux");

@StateVariable StrainStensor eel;
eel.setGlossaryName("ElasticStrain");
@StateVariable strain p;
p.setGlossaryName("EquivalentPlasticStrain");
@StateVariable real s;
s.setEntryName("EntropyPerUnitOfMass");

@TangentOperatorBlocks{∂σ∕∂Δεᵗᵒ, ∂σ∕∂ΔT, ∂s∕∂ΔT, ∂s∕∂Δεᵗᵒ, ∂j∕∂Δ∇T};

@StaticVariable real Tref = 293;

@Parameter stress E = 70e3;
E.setGlossaryName("YoungModulus");
@Parameter real ν = 0.3;
ν.setGlossaryName("PoissonRatio");
@Parameter stress H = 700.;
H.setEntryName("HardeningSlope");
@Parameter stress s0 = 250.;
s0.setGlossaryName("YieldStress");
@Parameter massdensity ρ = 2700.;
ρ.setGlossaryName("MassDensity");
@Parameter thermalconductivity α = 2.31e-5 ;
α.setGlossaryName("ThermalExpansion");
@Parameter real Cₑ = 910e-6;
Cₑ.setEntryName("SpecificHeatAtConstantStrainPerUnitOfMass");
@Parameter thermalconductivity k = 237e-6;
k.setGlossaryName("ThermalConductivity");

@PredictionOperator{
  // silent "unused parameter" warning
  static_cast<void>(smt);
  const auto λ = computeLambda(E, ν);
  const auto μ = computeMu(E, ν);
  ∂σ∕∂Δεᵗᵒ = λ ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ I₄;
}

@Integrator{
  const auto λ = computeLambda(E, ν);
  const auto μ = computeMu(E, ν);
  const auto κ = α ⋅ (2 ⋅ μ + 3 ⋅ λ);
  const auto ε = εᵗᵒ + Δεᵗᵒ;
  const auto εth = α ⋅ (T + ΔT - Tref) ⋅ I₂;

  eel += Δεᵗᵒ - εth;
  const auto se     = 2*μ*deviator(eel);
  const auto seq_e  = sigmaeq(se);
  const auto b      = seq_e-s0-H*p>stress{0};
  if(b){
    const auto iseq_e = 1/seq_e;
    const auto n      = eval(3*se/(2*seq_e));
    const auto cste   = 1/(H+3*μ);
    dp   = (seq_e-s0-H*p)*cste;
    eel -= dp*n;
    if(computeTangentOperator_){
      if(smt==CONSISTENTTANGENTOPERATOR){
	∂σ∕∂Δεᵗᵒ = (λ ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ I₄
	      -4*μ*μ*(dp*iseq_e*(Stensor4::M()-(n^n))+cste*(n^n)));
      } else {
	∂σ∕∂Δεᵗᵒ = λ ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ I₄;
      }
    }
  } else {
    if(computeTangentOperator_){
      ∂σ∕∂Δεᵗᵒ = λ ⋅ (I₂ ⊗ I₂) + 2 ⋅ μ ⋅ I₄;
    }
  }

  σ = λ ⋅ trace(eel) ⋅ I₂ + 2 ⋅ μ ⋅ eel ;
  s = Cₑ / Tref ⋅ (T + ΔT - Tref) + (κ / ρ) ⋅ trace(ε);
  j = -k ⋅ (∇T + Δ∇T);
  if (computeTangentOperator_) {
    ∂σ∕∂ΔT = -κ ⋅ I₂;
    ∂s∕∂ΔT = Cₑ / Tref;
    ∂s∕∂Δεᵗᵒ = κ / ρ ⋅ I₂;
    ∂j∕∂Δ∇T = -k ⋅ tmatrix<N, N, real>::Id();
  }
}
